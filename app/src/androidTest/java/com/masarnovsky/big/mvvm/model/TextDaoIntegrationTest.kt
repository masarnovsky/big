//package com.masarnovsky.big.mvvm.model
//
//import androidx.room.Room
//import androidx.test.core.app.ApplicationProvider
//import androidx.test.ext.junit.runners.AndroidJUnit4
//import app.cash.turbine.test
//import com.google.common.truth.Truth.assertThat
//import kotlinx.coroutines.test.runTest
//import org.junit.After
//import org.junit.Before
//import org.junit.Test
//import org.junit.runner.RunWith
//
///**
// * Comprehensive integration tests for Room database and DAO operations.
// * Tests actual database behavior with in-memory database.
// * Covers green (happy path), red (error), and tricky (concurrency, edge) cases.
// */
//@RunWith(AndroidJUnit4::class)
//class TextDaoIntegrationTest {
//
//    private lateinit var database: TextDatabase
//    private lateinit var dao: TextDao
//
//    @Before
//    fun setup() {
//        database = Room.inMemoryDatabaseBuilder(
//            ApplicationProvider.getApplicationContext(),
//            TextDatabase::class.java
//        ).allowMainThreadQueries() // Only for testing
//            .build()
//
//        dao = database.textDao()
//    }
//
//    @After
//    fun tearDown() {
//        database.close()
//    }
//
//    // ===== GREEN CASES (Happy Paths) =====
//
//    @Test
//    fun insertSingleText_shouldStoreAndRetrieve() = runTest {
//        val textEntity = TextEntity(text = "Test text")
//
//        dao.insert(textEntity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(1)
//            assertThat(items[0].text).isEqualTo("Test text")
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertMultipleTexts_shouldStoreAllInCorrectOrder() = runTest {
//        val texts = listOf(
//            TextEntity(text = "First", timestamp = 1000),
//            TextEntity(text = "Second", timestamp = 2000),
//            TextEntity(text = "Third", timestamp = 3000)
//        )
//
//        texts.forEach { dao.insert(it) }
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(3)
//            // Should be in descending order (newest first)
//            assertThat(items[0].text).isEqualTo("Third")
//            assertThat(items[1].text).isEqualTo("Second")
//            assertThat(items[2].text).isEqualTo("First")
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun deleteText_shouldRemoveFromDatabase() = runTest {
//        val entity = TextEntity(text = "To Delete")
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(1)
//
//            dao.delete(items[0])
//
//            val updatedItems = awaitItem()
//            assertThat(updatedItems).isEmpty()
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun getAllTexts_emptyDatabase_shouldReturnEmptyList() = runTest {
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).isEmpty()
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertWithAutoGeneratedId_shouldCreateUniqueIds() = runTest {
//        val text1 = TextEntity(text = "First")
//        val text2 = TextEntity(text = "Second")
//
//        dao.insert(text1)
//        dao.insert(text2)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].id).isNotEqualTo(0)
//            assertThat(items[1].id).isNotEqualTo(0)
//            assertThat(items[0].id).isNotEqualTo(items[1].id)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertWithAutoGeneratedTimestamp_shouldSetTimestamp() = runTest {
//        val entity = TextEntity(text = "Test")
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].timestamp).isGreaterThan(0L)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    // ===== RED CASES (Error Handling) =====
//
//    @Test
//    fun deleteNonExistentText_shouldNotCrash() = runTest {
//        val nonExistent = TextEntity(id = 999, text = "Doesn't exist", timestamp = 0)
//
//        dao.delete(nonExistent)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).isEmpty()
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertEmptyText_shouldStoreSuccessfully() = runTest {
//        val emptyEntity = TextEntity(text = "")
//
//        dao.insert(emptyEntity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEmpty()
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun deleteFromEmptyDatabase_shouldNotCrash() = runTest {
//        val entity = TextEntity(id = 1, text = "Test", timestamp = 100)
//
//        dao.delete(entity)
//
//        dao.getAllTexts().test {
//            assertThat(awaitItem()).isEmpty()
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    // ===== TRICKY CASES (Edge Cases & Concurrency) =====
//
//    @Test
//    fun insertEmoji_shouldStoreAndRetrieveCorrectly() = runTest {
//        val emojiText = "üåçüéâüòÄüíØ‚ú®üöÄ"
//        val entity = TextEntity(text = emojiText)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEqualTo(emojiText)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertUnicodeCharacters_shouldStoreCorrectly() = runTest {
//        val unicodeText = "Hello ‰∏ñÁïå ŸÖÿ±ÿ≠ÿ®ÿß –ü—Ä–∏–≤–µ—Ç ‡§®‡§Æ‡§∏‡•ç‡§§‡•á"
//        val entity = TextEntity(text = unicodeText)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEqualTo(unicodeText)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertMultilineText_shouldPreserveNewlines() = runTest {
//        val multilineText = "Line 1\nLine 2\nLine 3\nLine 4"
//        val entity = TextEntity(text = multilineText)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEqualTo(multilineText)
//            assertThat(items[0].text.lines()).hasSize(4)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertSpecialCharacters_shouldStoreCorrectly() = runTest {
//        val specialText = "Test !@#\$%^&*()_+-={}[]|:;<>,.?/~`"
//        val entity = TextEntity(text = specialText)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEqualTo(specialText)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertVeryLongText_shouldStoreCorrectly() = runTest {
//        val longText = "a".repeat(1000)
//        val entity = TextEntity(text = longText)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).hasLength(1000)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertManyRecords_shouldHandleEfficiently() = runTest {
//        repeat(100) { i ->
//            dao.insert(TextEntity(text = "Text $i", timestamp = i.toLong()))
//        }
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(100)
//            // Should be ordered by timestamp DESC
//            assertThat(items.first().text).isEqualTo("Text 99")
//            assertThat(items.last().text).isEqualTo("Text 0")
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun concurrentInserts_shouldAllBeStored() = runTest {
//        val texts = List(50) { i ->
//            TextEntity(text = "Concurrent $i", timestamp = i.toLong())
//        }
//
//        texts.forEach { dao.insert(it) }
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(50)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun rapidInsertAndDelete_shouldMaintainConsistency() = runTest {
//        dao.getAllTexts().test {
//            assertThat(awaitItem()).isEmpty()
//
//            // Rapid inserts
//            repeat(20) { i ->
//                dao.insert(TextEntity(text = "Text $i", timestamp = i.toLong()))
//                val items = awaitItem()
//                assertThat(items).hasSize(i + 1)
//            }
//
//            // Rapid deletes
//            val allItems = expectMostRecentItem()
//            allItems.take(10).forEach { item ->
//                dao.delete(item)
//                awaitItem()
//            }
//
//            val finalItems = expectMostRecentItem()
//            assertThat(finalItems).hasSize(10)
//
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertWithSameTimestamp_shouldBothBeStored() = runTest {
//        val timestamp = System.currentTimeMillis()
//        val text1 = TextEntity(text = "First", timestamp = timestamp)
//        val text2 = TextEntity(text = "Second", timestamp = timestamp)
//
//        dao.insert(text1)
//        dao.insert(text2)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(2)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertWithZeroTimestamp_shouldStoreSuccessfully() = runTest {
//        val entity = TextEntity(text = "Zero timestamp", timestamp = 0)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].timestamp).isEqualTo(0)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertWithNegativeTimestamp_shouldStoreSuccessfully() = runTest {
//        val entity = TextEntity(text = "Negative timestamp", timestamp = -1000)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].timestamp).isEqualTo(-1000)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertWithMaxLongTimestamp_shouldStoreSuccessfully() = runTest {
//        val entity = TextEntity(text = "Max timestamp", timestamp = Long.MAX_VALUE)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].timestamp).isEqualTo(Long.MAX_VALUE)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun deleteMiddleItem_shouldOnlyDeleteThatItem() = runTest {
//        val texts = listOf(
//            TextEntity(text = "First", timestamp = 1000),
//            TextEntity(text = "Second", timestamp = 2000),
//            TextEntity(text = "Third", timestamp = 3000)
//        )
//        texts.forEach { dao.insert(it) }
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(3)
//
//            // Delete middle item
//            dao.delete(items[1])
//
//            val updated = awaitItem()
//            assertThat(updated).hasSize(2)
//            assertThat(updated.map { it.text }).containsExactly("Third", "First")
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertDeleteInsert_sameText_shouldAllowReinsertion() = runTest {
//        val text = "Reusable text"
//
//        dao.getAllTexts().test {
//            assertThat(awaitItem()).isEmpty()
//
//            dao.insert(TextEntity(text = text))
//            var items = awaitItem()
//            assertThat(items).hasSize(1)
//
//            dao.delete(items[0])
//            items = awaitItem()
//            assertThat(items).isEmpty()
//
//            dao.insert(TextEntity(text = text))
//            items = awaitItem()
//            assertThat(items).hasSize(1)
//            assertThat(items[0].text).isEqualTo(text)
//
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun flowEmitsUpdates_whenDataChanges() = runTest {
//        dao.getAllTexts().test {
//            assertThat(awaitItem()).isEmpty()
//
//            dao.insert(TextEntity(text = "First"))
//            assertThat(awaitItem()).hasSize(1)
//
//            dao.insert(TextEntity(text = "Second"))
//            assertThat(awaitItem()).hasSize(2)
//
//            dao.insert(TextEntity(text = "Third"))
//            val items = awaitItem()
//            assertThat(items).hasSize(3)
//
//            dao.delete(items[0])
//            assertThat(awaitItem()).hasSize(2)
//
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertTextWithQuotes_shouldEscapeCorrectly() = runTest {
//        val textWithQuotes = "He said \"Hello\" and she replied 'Hi'"
//        val entity = TextEntity(text = textWithQuotes)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEqualTo(textWithQuotes)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertTextWithBackslashes_shouldStoreCorrectly() = runTest {
//        val textWithBackslashes = "Path: C:\\Users\\Test\\file.txt"
//        val entity = TextEntity(text = textWithBackslashes)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items[0].text).isEqualTo(textWithBackslashes)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//
//    @Test
//    fun insertTextWithSQLKeywords_shouldNotCauseInjection() = runTest {
//        val sqlText = "SELECT * FROM users WHERE name='admin' OR '1'='1'"
//        val entity = TextEntity(text = sqlText)
//
//        dao.insert(entity)
//
//        dao.getAllTexts().test {
//            val items = awaitItem()
//            assertThat(items).hasSize(1)
//            assertThat(items[0].text).isEqualTo(sqlText)
//            cancelAndIgnoreRemainingEvents()
//        }
//    }
//}
